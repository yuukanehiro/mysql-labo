
% go run modify_main_ULID_company_id10種_最初に10万件入れとく_UserIDランダム_UserIDを 昇順TXと逆順TX複数Run.go

(略)

5XQ6RGMJ7CMRJHVRMB','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CMXKE6Z1K','DATA-1750286550205102000-89385'),('01JY2KAH5XQ6RGMJ7CN4B8P9CM','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CN9QK7H0N','DATA-1750286550205102000-88373'),('01JY2KAH5XQ6RGMJ7CNQB51NCZ','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CNTWX7QWP','DATA-1750286550205102000-25567'),('01JY2KAH5XQ6RGMJ7CNYH2MM34','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CP4NB1HTP','DATA-1750286550205102000-314'),('01JY2KAH5XQ6RGMJ7CPA3X9VWE','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CPE8WPED7','DATA-1750286550205102000-85287'),('01JY2KAH5XQ6RGMJ7CPQ4FEM30','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CPS69ZY68','DATA-1750286550205102000-40763'),('01JY2KAH5XQ6RGMJ7CQ25FPBEH','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CQ2EETMNT','DATA-1750286550205102000-2314'),('01JY2KAH5XQ6RGMJ7CQBFPRBDY','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CQF7DJEXQ','DATA-1750286550205102000-30276'),('01JY2KAH5XQ6RGMJ7CQRS5GBP3','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CR000CC6K','DATA-1750286550205102000-63144'),('01JY2KAH5XQ6RGMJ7CR4JM67CH','01JY2KAF73MSNQR26CBWDTVVCD','01JY2KAH5XQ6RGMJ7CR6TDM21G','DATA-1750286550205102000-97912') ON DUPLICATE KEY UPDATE `data`=VALUES(`data`)
2025/06/19 07:42:43 Tx for Company 10 completed
done

===

> SHOW ENGINE INNODB STATUS;

=====================================
2025-06-18 22:43:40 281473470951168 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 32 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 66 srv_active, 0 srv_shutdown, 5305 srv_idle
srv_master_thread log flush and writes: 0
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 7950
OS WAIT ARRAY INFO: signal count 7044
RW-shared spins 0, rounds 0, OS waits 0
RW-excl spins 0, rounds 0, OS waits 0
RW-sx spins 0, rounds 0, OS waits 0
Spin rounds per wait: 0.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx
------------------------
LATEST DETECTED DEADLOCK
------------------------
2025-06-18 22:07:27 281472980283136 ⭐️デッドロックの発生なし
*** (1) TRANSACTION:
TRANSACTION 1934, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s), undo log entries 1403
MySQL thread id 118, OS thread handle 281473439493888, query id 2150 192.168.65.1 root update
INSERT INTO `demo_deadlocks` (`id`,`company_id`,`user_id`,`data`) VALUES ('01JY2HABRZJ27BDQF6VE0JS7Q8','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6VFEYTK73','DATA-1750284447385636000-3497'),('01JY2HABRZJ27BDQF6VFRQQM5D','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6VJ51TXB2','DATA-1750284447385636000-16586'),('01JY2HABRZJ27BDQF6VN1M30NM','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6VRJTK7FV','DATA-1750284447385636000-61586'),('01JY2HABRZJ27BDQF6VRW7BNPE','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6VV611ER7','DATA-1750284447385636000-73938'),('01JY2HABRZJ27BDQF6VVXYQTXT','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6VYGX0D29','DATA-1750284447385636000-48411'),('01JY2HABRZJ27BDQF6W0B3KVQ1','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6W3CEZ1J7','DATA-1750284447385636000-25303'),('01JY2HABRZJ27BDQF6W4QDF8T6','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6W5MMKVRT','DATA-1750284447385636000-12587'),('01JY2HABRZJ27BDQF6W79CAH3V','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WB54FP5C','DATA-1750284447385636000-57890'),('01JY2HABRZJ27BDQF6WD2E7BKZ','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WED11CVZ','DATA-1750284447385636000-32387'),('01JY2HABRZJ27BDQF6WFBNT28Q','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WH5NYAG0','DATA-1750284447385636000-88075'),('01JY2HABRZJ27BDQF6WHNSCZAA','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WJPW5HSR','DATA-1750284447385636000-48609'),('01JY2HABRZJ27BDQF6WN0QV4RH','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WN4WDTBC','DATA-1750284447385636000-91989'),('01JY2HABRZJ27BDQF6WPTT9VS4','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WRB6GNV1','DATA-1750284447385636000-6484'),('01JY2HABRZJ27BDQF6WSFB65E4','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6WYBDA8EB','DATA-1750284447385636000-17764'),('01JY2HABRZJ27BDQF6WYTKSZWJ','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6X0M9AMNH','DATA-1750284447385636000-37847'),('01JY2HABRZJ27BDQF6X9D80352','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6XDCN7YDR','DATA-1750284447385636000-13989'),('01JY2HABRZJ27BDQF6XH6GGRWR','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6XMANW8M2','DATA-1750284447385636000-25206'),('01JY2HABRZJ27BDQF6XQEJXHMY','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6XX3VQTJ5','DATA-1750284447385636000-12120'),('01JY2HABRZJ27BDQF6Y0DFFXC6','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6Y0RWF02P','DATA-1750284447385636000-85970'),('01JY2HABRZJ27BDQF6Y5P3A7FE','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6Y8H4CN0D','DATA-1750284447385636000-56125'),('01JY2HABRZJ27BDQF6YKD1DQ35','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6YPD1VAFC','DATA-1750284447385636000-63195'),('01JY2HABRZJ27BDQF6YX14YHBM','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6Z068T8PE','DATA-1750284447385636000-82539'),('01JY2HABRZJ27BDQF6Z7GTSBQP','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6ZAG9NG5B','DATA-1750284447385636000-70433'),('01JY2HABRZJ27BDQF6ZFKTBQ0C','01JY2HA9N62YPM3DMWZ9BEBZZ9','01JY2HABRZJ27BDQF6ZFKTYDGB','DATA-1750284447385636000-30066'),(


====

 補足：なぜ昇順で統一するのか？
InnoDBは複数レコードを更新する際、インデックスの順にロックを取得する。

トランザクションごとにその順番がバラバラだと、以下のような交差待ちになる：

csharp
コピーする
編集する
Tx1: lock A → lock B → ...
Tx2: lock B → lock A → ... ← Deadlock
一貫した順序（たとえば常に UserID 昇順）でアクセスすれば、上記のような競合を避けられる。

✅ 結論
ロック順序をすべてのTxで統一すれば、デッドロックは基本的に防げる。

この原則は、特に ON DUPLICATE KEY UPDATE のような「既存キーの探索＋更新」を伴う操作で重要。

この修正により、性能と安全性が両立できるようになります。

必要であれば「どんな順序を選ぶべきか」「シャーディング的にTxを分離する方法」などのLTネタも補強できます。希望があればお伝えください。



 supremum pseudo-record とは？完全解説
💡 一言で言うと：
B+Tree の最終ページの一番右の “末尾” にある仮想的なレコード。

実データとしては存在しないが、「このページに挿入されるかもしれない」場所を表現するために使われます。

📚 背景知識：InnoDB のレコード構造
InnoDBはデータを クラスタ化インデックス（B+Tree） に格納します。各ページ（Leaf node）には、

実際のレコード（通常の行データ）

infimum pseudo-record: ページの先頭を表す仮想行

supremum pseudo-record: ページの末尾を表す仮想行

という「補助的な仮想レコード」が存在します。

✅ 具体例：Leafページのイメージ
text
コピーする
編集する
| infimum | 実レコードA | 実レコードB | ... | 実レコードZ | supremum |
この supremum は、Zの後ろに新しいレコードが挿入されるときにロック対象になる。

🧷 どんなときに supremum pseudo-record にロックがかかるの？
1. 挿入（INSERT）時
B+Treeの末尾に新しいキー（レコード）を追加するとき、最終ページの末尾に位置するこの supremum に GAPロック or INSERT INTENTIONロック を付ける。

2. 他のトランザクションが末尾に挿入中のとき
別のトランザクションが supremum をロックしていると、INSERTはブロック or デッドロックする。

🎯 なぜ重要か？（LTでのポイント）
supremum ロックは、複数のINSERTがB+Treeの末尾を狙った時に競合する

特に AUTO_INCREMENTキーのINSERTが連続すると、ここでのロック競合が起きる

デッドロックログには "supremum pseudo-record" として頻出するため、知らないと詰まる

🧠 質問への対応例
Q：「supremum pseudo-recordってデータじゃないのになんでロックされるの？」
A：「supremumは“末尾の挿入ポイント”としてInnoDB内部に仮想的に存在するからです。
実データはないけれど、複数のINSERTが競合しないように、ロック対象として扱います。」

Q：「実際に見える？デバッグできる？」
A：「はい、performance_schema.data_locks に LOCK_DATA = supremum pseudo-record として現れます。これは挿入待ちのトランザクションが 末尾を狙っている 状態を意味します。」

🧾 要点まとめ（3行で）
supremum pseudo-record はB+Treeの末尾の「仮想レコード」

INSERT時にこの位置を他トランザクションと取り合うことでロック競合が起きる

AUTO_INCREMENTによる挿入競合やデッドロックの温床になるので分析・対処に重要


 ===

InnoDB のロックの分類体系
1. ロックの基本型（主に LOCK_MODE に出現）
ロック種別	意味・対象	用途・発生タイミング
S（共有ロック）	レコードの読みを他のトランザクションと共有	SELECT ... LOCK IN SHARE MODEなど
X（排他ロック）	レコードの読み書きを独占	UPDATE・DELETE・INSERT時に発生

2. ロックの補助属性（GAP, REC_NOT_GAP, INSERT_INTENTION など）
これらは「補助フラグ」のようなもので、対象レコードのどの領域にどんな操作意図を持つかを示します。

補助属性	意味・対象範囲	典型的な発生例
GAP	対象レコード「前の隙間（gap）」に対するロック	SELECT ... FOR UPDATE（非一意INDEX）など
REC_NOT_GAP	対象レコード「自身のみ」に対するロック	SELECT ... FOR UPDATE（一意INDEX）など
INSERT_INTENTION	Insert意図を表す意図ロック（Intent Lock）	他のTxがGAPロック中に INSERT したとき
X, GAP, INSERT_INTENTION	INSERT予定のレコード前のGAPに、他Txが持つ排他ロックとの衝突を避ける	INSERT 同士で発生、デッドロックの温床

🔍 実例付き：LOCK_MODE の構成パターンとその意味
✅ X, REC_NOT_GAP
意味：対象レコード自体を排他ロック。GAPや隣接レコードには影響なし。

発生例：一意インデックスで SELECT ... FOR UPDATE。

🎤 質問例：「このロックはなぜ他の挿入と干渉しないの？」
→ 回答：「GAPにはロックしていないため、前後のInsertは可能です」

✅ X, GAP
意味：対象レコード前後の隙間を含めたロック。

発生例：非一意インデックス上での SELECT ... FOR UPDATE や範囲検索

🎤 質問例：「なんでギャップもロックするの？」
→ 回答：「範囲条件で重複挿入を防ぐためです（幻影行＝phantom防止）」

✅ X, GAP, INSERT_INTENTION
意味：他トランザクションが持っている GAP ロックの前提で、「自分も挿入したい」ことを示す意図ロック

発生例：複数トランザクションが同一箇所にINSERTしようとしたとき

🎤 質問例：「意図ロックって何のためにあるの？」
→ 回答：「他のトランザクションに対して、“私はこのGAPに挿入予定だ”と表明するためです」

✅ X, REC_NOT_GAP + WAITING
意味：レコード本体だけの排他ロックを取得待ち状態

発生例：誰かがそのレコードに対し X ロックを保持していて、自分がそのロックを待っているとき

🎤 質問例：「WAITING の時はどうなるの？」
→ 回答：「そのスレッドはブロックされ、InnoDBがデッドロック検出に動きます」

🧠 よくある質問（FAQ形式）
Q1. GAPロックって挿入防止用なのに、なぜDELETEにも使われるの？
DELETEもSELECT ... FOR UPDATEと同じく、「幻影行の防止」が必要。範囲内に新たな行を挿入させないようにするため。

Q2. GAPロックとINSERT_INTENTIONロックは同時に取れるの？
YES。異なるトランザクションが互いに GAP を持ちつつ INSERT_INTENTION を出すことで競合が生まれる。この組み合わせが典型的なデッドロックの温床。

Q3. supremum pseudo-recordって何？
B+Treeの最終ノードの後ろの「仮想レコード」。全てのレコードの末尾に対して何か挿入しようとする場合にロックされる。